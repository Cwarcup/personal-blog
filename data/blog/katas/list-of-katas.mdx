---
title: Kata - Practice Problems
date: '2022-05-22'
tags: ['Kata']
draft: false
summary: Large list of popular Katas to practice different programming patterns.
---

<TOCInline toc={props.toc} asDisclosure />

# What is a Kata?

According to [Wikipedia](https://en.wikipedia.org/wiki/Kata), "Kata (型 or 形 literally: "form"), a Japanese word, are detailed choreographed patterns of movements practiced either solo or in pairs."

![Kata](https://media.giphy.com/media/J2xkAW1E8kvyE/giphy.gif)

We will be using Katas to practice different programming patterns.

# Check Air Quality

For this challenge we will implement a function called `checkAir()`, which will check a collection of air samples.

The function will take in two arguments.

- The first argument is an array of strings, where each string represents a small air sample that is either `clean` or `dirty`.
- The second argument is a number representing the **highest acceptable amount of dirty samples**. For example, a threshold of 0.4 means that there must be less than 40% of total samples classified as dirty for our air to be considered clean.

Our function must return `Polluted` if there are **too many dirty air samples**, or `Clean` if the proportion of dirty samples is **below the threshold**.

```js
const checkAir = function (samples, threshold) {
  const numOfSamples = samples.length
  const dirtySamples = counter(samples, 'dirty')

  return dirtySamples / numOfSamples > threshold ? 'Polluted' : 'Clean'
}

function counter(samples, result) {
  let count = 0
  for (let char of samples) {
    if (char === result) {
      count++
    }
  }
  return count
}

console.log(
  checkAir(
    // should return 'Polluted'
    ['clean', 'clean', 'dirty', 'clean', 'dirty', 'clean', 'clean', 'dirty', 'clean', 'dirty'],
    0.3
  )
)

console.log(
  checkAir(
    // should return 'Polluted'
    ['dirty', 'dirty', 'dirty', 'dirty', 'clean'],
    0.25
  )
)

console.log(
  checkAir(
    // should return 'Clean'
    ['clean', 'dirty', 'clean', 'dirty', 'clean', 'dirty', 'clean'],
    0.9
  )
)
```

# Conditional Sums

Adding only the numbers in the array which match the given condition.

```js
const conditionalSum = function (values, condition) {
  let result = []
  values.map((item) => {
    if (condition === 'even') {
      if (item % 2 === 0) {
        result.push(item)
      }
    } else if (condition === 'odd') {
      if (item % 2 !== 0) {
        result.push(item)
      }
    }
  })
  return result.reduce((partialSum, item) => partialSum + item, 0)
}

// or

const conditionalSum = function (values, condition) {
  let sum = 0
  for (let i = 0; i < values.length; i++) {
    if (condition === 'even' && values[i] % 2 === 0) {
      sum += values[i]
    } else if (condition === 'odd' && values[i] % 2 !== 0) {
      sum += values[i]
    }
  }
  return sum
}

console.log(conditionalSum([1, 2, 3, 4, 5], 'even')) // 6
console.log(conditionalSum([1, 2, 3, 4, 5], 'odd')) // 9
console.log(conditionalSum([13, 88, 12, 44, 99], 'even')) // 144
console.log(conditionalSum([], 'odd')) // 0
```

# Longest Name

Given a list of names, return which instructor has the longest name.

```js
const instructorWithLongestName = function (instructors) {
  let maxIndex = 0

  for (let i = 0; i < instructors.length; i++) {
    if (instructors[i].name.length > instructors[maxIndex].name.length) {
      maxIndex = i
    }
  }
  return instructors[maxIndex]
}

console.log(
  instructorWithLongestName([
    // {name: "Jeremiah", course: "Web"}
    { name: 'Samuel', course: 'iOS' },
    { name: 'Jeremiah', course: 'Web' },
    { name: 'Ophilia', course: 'Web' },
    { name: 'Donald', course: 'Web' },
  ])
)
console.log(
  instructorWithLongestName([
    // {name: "Domascus", course: "Web"}
    { name: 'Matthew', course: 'Web' },
    { name: 'David', course: 'iOS' },
    { name: 'Domascus', course: 'Web' },
  ])
)
```

# Percent Encoded String

Given a normal string of words, turn it into a percent-encoded string by replacing all whitespace with %20.
Take a look at the following URL, specifically the last part:

```
https://www.google.com/search?q=javascript+string+replace+whitespace
```

This URL will perform a google search for the term "javascript string replace whitespace". Notice that when the string "javascript string replace whitespace" is part of a URL, the space is replaced with `%20`

For this exercise, focusing on replacing the spaces with `%20`.

```js
const urlEncode = function (text) {
  return text.replace(/[\s]/g, '%20')
}

// without replace

const urlEncode = function (text) {
  let result = ''

  for (let char of text.trim().split('')) {
    if (char === ' ') {
      char = '%20'
      result = result + char
    } else {
      result = result + char
    }
  }
  return result
}

console.log(urlEncode('Curtis Warcup')) // "Curtis%20Warcup"
console.log(urlEncode(' Curtis Warcup ')) // "%20Curtis%20Warcup%20"
console.log(urlEncode('dogs are super cool')) // "dogs%20are%20super%20cool"
```

# Sum of Largest Numbers

Given an array of 2 or more numbers. Find the two largest numbers in that array, and sum them together.

```js
const sumLargestNumbers = function (data) {
  let num1 = data
    .sort((a, b) => {
      return a - b
    })
    .pop()

  let num2 = data
    .sort((a, b) => {
      return a - b
    })
    .pop()

  return num1 + num2
}

console.log(sumLargestNumbers([1, 10])) // 11
console.log(sumLargestNumbers([1, 2, 3])) // 5
console.log(sumLargestNumbers([10, 4, 34, 6, 92, 2])) // 126
```

# Count Number of Vowels

Counting the number of vowels that appear in a given string.

```js
const numberOfVowels = function (data) {
  let result = data.match(/[aeiou]/gi)
  return (result = result ? result.length : 0)
}

console.log(numberOfVowels('orange')) // 2
console.log(numberOfVowels('Curtis Warcup')) // 4
console.log(numberOfVowels('aeiou')) // 5
console.log(numberOfVowels('')) // 0
```

# Where can I park?

We need to write a function called `whereCanIPark()` that returns the coordinates of an available parking spot for the vehicle, or returns false if there is no available spot. Our function receives an array of arrays representing parking spots, and a string with type of the vehicle that is looking for a parking spot.

There are three kinds of possible vehicles: **regular** cars, **small** cars, and **motorcycles**.

- Regular cars can only park in **R** spots.
- Small cars can park in **R** or **S** spots.
- Motorcycles can park in **R**, **S**, or **M** spots.

In the array of parking spots, spots are written in both lower-case and upper-case. An upper-case letter means that the particular spot is **AVAILABLE**, while lower-case letters mean that the spot is **UNAVAILABLE**.

Our function must return an array with the coordinates of the spot as an `[X, Y]` pair. See the example input and output below for an illustration.

```js
console.log(
  whereCanIPark(
    // [4, 0]
    [
      // COLUMNS ARE X
      // 0    1    2    3    4    5
      ['s', 's', 's', 'S', 'R', 'M'], // 0 ROWS ARE Y
      ['s', 'M', 's', 'S', 'r', 'M'], // 1
      ['s', 'M', 's', 'S', 'r', 'm'], // 2
      ['S', 'r', 's', 'm', 'r', 'M'], // 3
      ['S', 'r', 's', 'm', 'r', 'M'], // 4
      ['S', 'r', 'S', 'M', 'M', 'S'], // 5
    ],
    'regular'
  )
)
```

Possible solution:

```js
const whereCanIPark = function (spots, vehicle) {
  const avail = vehicleSpots(vehicle)

  for (let row = 0; row < spots.length; row++) {
    for (let col = 0; col < spots.length; col++) {
      let char = spots[row][col]
      if (avail.indexOf(char) > -1) {
        return new Array(col, row)
      }
    }
  }
  return false
}

function vehicleSpots(vehicle) {
  let avail

  if (vehicle === 'regular') {
    return (avail = 'R')
  } else if (vehicle === 'small') {
    return (avail = 'RS')
  } else if (vehicle === 'motorcycle') {
    return (avail = 'RSM')
  } else {
    return 'Need to add type of vehicle'
  }
}

console.log(vehicleSpots('regular'))
console.log(vehicleSpots('small'))
console.log(vehicleSpots('motorcycle'))

console.log(
  whereCanIPark(
    // [3, 1]
    [
      ['s', 's', 's', 's', 's', 's'],
      ['s', 'm', 's', 'S', 'r', 's'],
      ['s', 'm', 's', 'S', 'r', 's'],
      ['S', 'r', 's', 'm', 'r', 's'],
      ['S', 'r', 's', 'm', 'R', 's'],
      ['S', 'r', 'S', 'M', 'm', 'S'],
    ],
    'motorcycle'
  )
)
console.log(
  whereCanIPark(
    // [4, 0]
    [
      // COLUMNS ARE X
      // 0    1    2    3    4    5
      ['s', 's', 's', 'S', 'R', 'M'], // 0 ROWS ARE Y
      ['s', 'M', 's', 'S', 'r', 'M'], // 1
      ['s', 'M', 's', 'S', 'r', 'm'], // 2
      ['S', 'r', 's', 'm', 'r', 'M'], // 3
      ['S', 'r', 's', 'm', 'r', 'M'], // 4
      ['S', 'r', 'S', 'M', 'M', 'S'], // 5
    ],
    'regular'
  )
)

console.log(
  whereCanIPark(
    // false
    [
      ['M', 'M', 'M', 'M'],
      ['M', 's', 'M', 'M'],
      ['M', 'M', 'M', 'M'],
      ['M', 'M', 'r', 'M'],
    ],
    'small'
  )
)
```

# Repeating Numbers

The input data for this exercise will be two dimensional array (an array of arrays), where each sub-array will have two numeric values. For example:

```js
;[
  [1, 2],
  [2, 3],
]
```

The first will be the value to **repeat**, the second will be the amount of **times to repeat** that value.

```js
const repeatNumbers = function (data) {
  let values = []

  for (let i = 0; i < data.length; i++) {
    let result = ''
    for (let repeats = 0; repeats < data[i][1]; repeats++) {
      result += data[i][0]
    }
    values.push(result)
  }
  return values.join(', ')
}

console.log(repeatNumbers([[1, 10]])) // 1111111111
console.log(
  repeatNumbers([
    [1, 2],
    [2, 3],
  ])
) // 11, 222
console.log(
  repeatNumbers([
    [10, 4],
    [34, 6],
    [92, 2],
  ])
) // 10101010, 343434343434, 9292
```

# Talking Calender

In this activity, we will be converting date strings like "2017/12/02", into more English friendly date strings like "December 2nd, 2017".

We will be given a date as a string (not a `Date` object). The date will always be formatted as `YYYY/MM/DD`. We will have to parse the given string and produce a human readable date.

```js
const talkingCalendar = function (date) {
  const monthNames = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
  ]

  let monthIndex = new Date(date).getMonth()
  let year = new Date(date).getFullYear()
  let month = monthNames[monthIndex]
  let day = parseInt(date.slice(8, 10))

  const nth = function (day) {
    if (day > 3 && day < 21) return `${day}th`
    switch (day % 10) {
      case 1:
        return `${day}st`
      case 2:
        return `${day}nd`
      case 3:
        return `${day}rd`
      default:
        return `${day}th`
    }
  }

  return `${month} ${nth(day)}, ${year}`
}

console.log(talkingCalendar('2017/12/02')) // December 2nd, 2017
console.log(talkingCalendar('2007/11/11')) // November 11th, 2007
console.log(talkingCalendar('1987/08/24')) // August 24th, 1987
```

# Change Calculator

Create a function that can calculate which coins we should use when we need to give change.

We will be given two numbers, the **total of a transaction**, and the amount of **cash given to the cashier**. Both of these numbers will be represented as whole numbers in **cents**. Therefore $10 will be represented as `1000`.

Our function `calculateChange` should return an object which describes the total amount of change for the cashier to give back. Although pennies are not used in circulation, we will still calculate the amount of pennies to give back.

Valid denominations are as follows:

- Twenty dollars
- Ten dollars
- Five dollars
- Two dollars
- One dollar
- Quarter (25¢)
- Dime (10¢)
- Nickel (5¢)
- Penny (1¢)

Create a function named `calculateChange` that takes in a total amount of a bill and the total cash given to pay that bill. Return a new object that describes the total amount of change for the cashier to give back. Omit any types of change that you shouldn't give back, i.e. if you don't give back a twenty dollar bill, don't include it in the results.

```js
const calculateChange = function (total, cash) {
  const getDollarCents = (total, cash) => {
    const amountOwed = cash - total
    const centString = amountOwed.toString()
    const totalCents = centString.slice(centString.length - 2, centString.length)
    const totalDollars = centString.slice(0, centString.length - 2)
    return [totalDollars, totalCents]
  }

  let dollarsOwed = getDollarCents(total, cash)[0]
  let dollarsBack = 0
  let changeObj = {}
  while (dollarsBack < dollarsOwed) {
    if (dollarsBack + 20 <= dollarsOwed) {
      changeObj['twentyDollar'] = Math.floor((dollarsOwed - dollarsBack) / 20)
      dollarsBack += 20 * changeObj['twentyDollar']
    } else if (dollarsBack + 10 <= dollarsOwed) {
      changeObj['tenDollar'] = Math.floor((dollarsOwed - dollarsBack) / 10)
      dollarsBack += 10 * changeObj['tenDollar']
    } else if (dollarsBack + 5 <= dollarsOwed) {
      changeObj['fiveDollar'] = Math.floor((dollarsOwed - dollarsBack) / 5)
      dollarsBack += 5 * changeObj['fiveDollar']
    } else if (dollarsBack + 2 <= dollarsOwed) {
      changeObj['twoDollar'] = Math.floor((dollarsOwed - dollarsBack) / 2)
      dollarsBack += 2 * changeObj['twoDollar']
    } else if (dollarsBack + 1 <= dollarsOwed) {
      changeObj['oneDollar'] = Math.floor((dollarsOwed - dollarsBack) / 1)
      dollarsBack += 1 * changeObj['oneDollar']
    } else {
      break
    }
  }

  let centsOwed = getDollarCents(total, cash)[1]
  let centsBack = 0
  while (centsBack < centsOwed) {
    if (centsBack + 25 <= centsOwed) {
      changeObj['quarter'] = Math.floor((centsOwed - centsBack) / 25)
      centsBack += 25 * changeObj['quarter']
    } else if (centsBack + 10 <= centsOwed) {
      changeObj['dime'] = Math.floor((centsOwed - centsBack) / 10)
      centsBack += 10 * changeObj['dime']
    } else if (centsBack + 5 <= centsOwed) {
      changeObj['nickle'] = Math.floor((centsOwed - centsBack) / 5)
      centsBack += 5 * changeObj['nickle']
    } else if (centsBack + 1 <= centsOwed) {
      changeObj['penny'] = Math.floor(centsOwed - centsBack)
      centsBack += 1 * changeObj['penny']
    } else {
      break
    }
  }

  return changeObj
}

console.log(calculateChange(1787, 2000)) // { twoDollar: 1, dime: 1, penny: 3 }

console.log(calculateChange(2623, 4000))
// { tenDollar: 1, twoDollar: 1, oneDollar: 1, quarter: 3, penny: 2 }
console.log(calculateChange(501, 1000))
// { twoDollar: 2, quarter: 3, dime: 2, penny: 4 }
```

# Case Maker

We will receive a normal string of words separated with spaces as the input. Our job is to convert these strings into **camel** cased strings.

```js
const camelCase = function (input) {
  // Your code here
}

console.log(camelCase('this is a string')) // thisIsAString
console.log(camelCase('loopy lighthouse')) // loopyLighthouse
console.log(camelCase('supercalifragalisticexpialidocious')) // supercalifragalisticexpialidocious
```

Possible Solution:

```js
const camelCase = function (input) {
  const lowers = input.toLowerCase().split(' ') // in case any letters are already uppercase
  const result = [lowers.shift()]
  for (let word of lowers) {
    result.push(word[0].toUpperCase() + word.slice(1))
  }
  return result.join('')
}

console.log(camelCase('this is a string')) // thisIsAString
console.log(camelCase('loopy lighthouse')) // loopyLighthouse
console.log(camelCase('supercalifragalisticexpialidocious')) // supercalifragalisticexpialidocious
```

# Multiplication Table

We will be given a number as our input data. This number is the highest value of our multiplication table.

Our job is to generate a multiplication table for the values from 1 to the provided number.

For example:

```js
console.log(multiplicationTable(1))
// expect to return
// 1

console.log(multiplicationTable(5))
// expect to return
// 1 2 3 4 5
// 2 4 6 8 10
// 3 6 9 12 15
// 4 8 12 16 20
// 5 10 15 20 25

console.log(multiplicationTable(10))
// expect to return
// 1 2 3 4 5 6 7 8 9 10
// 2 4 6 8 10 12 14 16 18 20
// 3 6 9 12 15 18 21 24 27 30
// 4 8 12 16 20 24 28 32 36 40
// 5 10 15 20 25 30 35 40 45 50
// 6 12 18 24 30 36 42 48 54 60
// 7 14 21 28 35 42 49 56 63 70
// 8 16 24 32 40 48 56 64 72 80
// 9 18 27 36 45 54 63 72 81 90
// 10 20 30 40 50 60 70 80 90 100
```

Possible Solution:

```js
const multiplicationTable = function (maxValue) {
  // make array of maxValue number of empty arrays
  let result = []
  for (let i = 0; i < maxValue; i++) {
    result.push([])
  }

  let counter = 1
  let colStart = 0
  let colEnd = maxValue - 1
  let rowStart = 0
  let rowEnd = maxValue - 1

  // top row
  for (let i = colStart; i < maxValue; i++) {
    result[rowStart][i] = counter
    counter++
  }
  rowStart++
  counter = 2

  // left col
  for (let i = rowStart; i < maxValue; i++) {
    result[i][colStart] = counter
    counter++
  }
  colStart++

  // fill the array positions
  while (colStart <= colEnd && rowStart <= rowEnd) {
    if (result[rowStart].length <= maxValue) {
      for (let i = colStart; i <= colEnd; i++) {
        result[rowStart][i] = result[rowStart][0] * result[0][colStart]
        colStart++
      }
    }
    rowStart++
    colStart = 1
  }

  return result
}

console.log(multiplicationTable(1))
// expect to return
// 1

console.log(multiplicationTable(5))
// expect to return
// 1 2 3 4 5
// 2 4 6 8 10
// 3 6 9 12 15
// 4 8 12 16 20
// 5 10 15 20 25

console.log(multiplicationTable(10))
// expect to return
// 1 2 3 4 5 6 7 8 9 10
// 2 4 6 8 10 12 14 16 18 20
// 3 6 9 12 15 18 21 24 27 30
// 4 8 12 16 20 24 28 32 36 40
// 5 10 15 20 25 30 35 40 45 50
// 6 12 18 24 30 36 42 48 54 60
// 7 14 21 28 35 42 49 56 63 70
// 8 16 24 32 40 48 56 64 72 80
// 9 18 27 36 45 54 63 72 81 90
// 10 20 30 40 50 60 70 80 90 100
```
