---
title: React - State
date: '2022-08-08'
tags: ['state', 'hooks', 'react', 'props', 'style']
images: 'https://miro.medium.com/max/1200/1*hYSKyofnqThnPIsYRfnUUQ.png'
draft: false
summary: Understanding state in React, adding state to components, passing state from parent to child, controlled components, and methods of adding styles to components.
---

<TOCInline toc={props.toc} asDisclosure />

State is a piece of data that is stored in a component. It represents the current condition, values or contents of a program.

State in React allows us to dynamically change the contents of a component based on the value of a variable passed to a component. State also allows us to retain information across multiple renders.

We use **"hooks"**, specifically the **`useState`** hook, to manage state.

Use this repository to follow along with the examples: [here](https://github.com/Cwarcup/fancy-buttons)

## Using State in React

We must firs timport the `useState` hook from the React library.

```jsx
import { useState } from 'react'
```

- The `useState` function receives an _optional_ argument which is the **initial/default** value of the state.
- `useState` returns an array
  - first element is the **current** state
  - second element is a function to **update the state** (`setState`)
  - we use array deconstruction to extract the current state and the update state function

```jsx
import { useState } from 'react'

function Application(props) {
  const [count, setCount] = useState(0) // array deconstruction

  return (
    <main>
      <Button onClick={() => setCount(count + 1)}>Increment</Button>
      <h1>Button was clicked {count} times.</h1>
    </main>
  )
}
```

## Importing The useState Hook

- `useState` is a React hook, therefore it must be imported from the `React` object.

```jsx
import { useState } from 'react'
```

## Using useState

- Use the `useState` hook by calling it within our component.
- It must **NOT be called** within...
  - conditionals
  - loops
  - or other functions
- It must be called at the top level of our component.

Calling the `useState()` hook will return an **array** containing two values:

- a **reference** to get the current value of the state
- a **setter function** (i.e. a way to set the reference and re-render the app)
  - the setter function **needs** to **start** with the word `set` like in the example below.

```jsx
const [reference, setReference] = useState()
// or
const [state, setState] = useState()
```

> Use array deconstruction to extract the current state and the setter function.

Our app should look like so:

```js
function AngryButton(props) {
  const [anger, setAnger] = useState()
  //...
}
function CounterButton(props) {
  const [clickAmount, setClickAmount] = useState()
  //...
}
function LightSwitchButton(props) {
  const [light, setLight] = useState()
  //...
}
function TextRepeaterButton(props) {
  const [repetitions, setRepetitions] = useState()
  //...
}
```

For the Anger Button:

- we want the value of anger to go from 0 to 1 by increments of 0.1, and once we go over 1, reset it to zero. We need to use the value of anger in two places:
  - for the background color of the button
  - as a condition that will determine which message is displayed.

```jsx
import { useState } from 'react'

function AngryButton() {
  // count the percentage of anger
  const [anger, setAnger] = useState(0)
  return (
    <button style={{ backgroundColor: `rgba(255,0,0,${anger})` }} className="AngryButton">
      {anger < 1 && <span>Don't click me too much! </span>}
      {anger > 1 && <span>Rawr!</span>}
    </button>
  )
}

export default AngryButton
```

CounterButton:

- For this button, we want the value of clickAmount to start at 0 and increment by 1 with each click. We want to use the value of clickAmount in the text of the button.

```jsx
function CounterButton() {
  //count amount of clicks
  const [clickAmount, setClickAmount] = useState(0)

  return <button className="CounterButton">You clicked me {clickAmount} amount of times</button>
}
```

## Modifying The State

- Use the setter function (second argument) to update the state.

```jsx
let [x, setX] = useState(42)
// WRONG!
x = 99

// CORRECT!
setX(99)
```

For our click counter, we need to add an `onClick` event handler to the button. To keep our code clean, we will create a function that can be referenced in the event handler.

```jsx
  const handleClick = (event) => setState(event.target.value ? event.target.value : "");

  <button onClick={handleClick} />

  // instead of

  <button onClick={event => setState(event.target.value ? event.target.value : "")} />
```

For our project, it should look like this:

```jsx
function AngryButton() {
  // count the percentage of anger
  const [anger, setAnger] = useState(0)

  const handleClick = () => {
    if (anger < 1) {
      setAnger(anger + 0.1)
    } else {
      setAnger(0)
    }
  }

  return (
    <button
      onClick={handleClick}
      style={{ backgroundColor: `rgba(255,0,0,${anger})` }}
      className="AngryButton"
    >
      {anger < 1 && <span>Don't click me too much! </span>}
      {anger > 1 && <span>Rawr!</span>}
    </button>
  )
}
```

## Lifting State Up

Right now, only the component that uses the state has access to the state.

What if we wanted to share the state between components? We can do this by lifting the state up to the component that needs it.

Let's do this to change the background color of our `App` component (the parent to all these components).

> From the React docs: In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called _‚Äúlifting state up‚Äù_.

```jsx
// Before, only the AngryButton component has access to the state
function App() {
  return (
    // ...
    <LightSwitchButton />
  )
}

function LightSwitchButton(props) {
  const [light, setLight] = useState('off')
  // ...
}
```

```jsx
// After, now parent App component has access to the state
function App() {
  const [light, setLight] = useState('off')
  return (
    // ...
    <LightSwitchButton light={light} setLight={setLight} /> // pass as props
  )
}

// back over at the LightSwitchButton component
function LightSwitchButton(props) {
  const { light, setLight } = props // destructuring props
  // ...
}
```

## Adding a Dark Mode

We want to change the colour of our app.

- switch the backgrounds from white to black
- the text
- button borders from black to white.

We can accomplish that task by adding a `dark` **class** name to the **parent** `div` element inside the `App` component.

```css
.App.dark,
.App.dark button {
  background: #222;
  border-color: white;
  color: white;
}
```

## Passing Down State Values

In the child:

```jsx
function LightSwitchButton(props) {
  const { light, setLight } = props // destructuring props
  const handleClick = () => setLight(light === 'on' ? 'off' : 'on') // keep the handleClick function in the child component

  return (
    <button onClick={handleClick} className="LightSwitchButton">
      {light === 'on' && (
        <span className="on">
          <i>üí°</i> I'm on!
        </span>
      )}

      {light === 'off' && (
        <span className="off">
          <i>üí°</i> I'm off!
        </span>
      )}
    </button>
  )
}
```

In the parent:

```jsx
import './App.css'
import { useState } from 'react' // import useState from react
import LightSwitchButton from './components/LightSwitchButton'

function App() {
  //want to know if the light is on or off
  const [light, setLight] = useState('off') // useState is a hook

  return (
    <div className={'App dark'}>
      <h1>Fancy Buttons!</h1>
      <section>
        <LightSwitchButton light={light} setLight={setLight} /> // pass as props
      </section>
    </div>
  )
}
```

## Change From Dark To Light Mode

```jsx
function App() {
  //want to know if the light is on or off
  const [light, setLight] = useState('off') // default to off, in dark mode

  const dark = light === 'off' ? 'dark' : '' // if light is off, add the class dark to the parent div

  return (
    <div className={`App ${dark}`}>
      {' '}
      // conditional className
      <h1>Fancy Buttons!</h1>
      <section>
        <AngryButton />
        <CounterButton />
        <LightSwitchButton light={light} setLight={setLight} />
        <TextRepeaterButton />
      </section>
    </div>
  )
}
```

## Better Parent State Modifications

It is good practice to keep logic that changes the state near the declaration, and not in a child component. The reason behind this is that if the code that changes the state is written in a component that is several levels down, it can be hard to find the source of a bug.

```jsx
//child

const { light, switchLight } = props

// ...
;<button onClick={switchLight} className="LightSwitchButton"></button>
```

```jsx
// parent
<LightSwitchButton light={light} setLight={setLight} switchLight={switchLight} />
```

We ca forgo `handleClick` and give `switchLight` **directly** to the `onClick` event listener.

## Controlled Components

In HTML we use form elements to get user input and create interactive websites. An important thing forms do is keep track of their state by using an `<input>` element to keep track of the `value` of the input.

However, recall that React uses does not need to this. It has other ways of keeping track of state.

**Controlled Components** are ones that **override** HTML form elements to let React control their state.

Controlled components pattern:

1. Set a variable that is stored in state as the `value` attribute on the `form` element.
1. Use an `onChange` event that uses the **setter** of your state to set a new value when the `input` changes.

Recall from reading about event handling that events in the DOM generate event objects which have lots of useful information for programmers.

When the user types on the keyboard, that triggers the `onChange` event and the value of the data is found in `event.target.value`.

Example:

```jsx
function DisplayWord(props) {
  const [word, setWord] = useState('')

  return (
    <main>
      <input
        value={word}
        onChange={(event) => setWord(event.target.value)}
        placeholder="Please enter a word"
      />
      <h1>Your word is: {word}.</h1>
    </main>
  )
}
```

> As noted above, the `<input>` element becomes a **controlled component** when we provide a `value` prop and an `onChange` event handler that can update the value

Read more about React forms [here](https://reactjs.org/docs/forms.html)

## Fragments

- Rule of JSX: all JSX expressions must have only **one** parent element.
  - Components can only return JSX with one root element.
  - Conditional expressions that resolve to JSX must also only have one root element.

```jsx
// BAD - wont work
return (
  <h1>A heading</h1>
  <p>A paragraph</p>
)

// OK - will work, but now have an extra div
return (
<div>
	<h1>A heading</h1>
	<p>A paragraph</p>
</div>
)

// GOOD - will work - SHORTHAND
return (
	<>
		<h1>A heading</h1>
		<p>A paragraph</p>
	</>
)

// GOOD - also works fine. Is same as above.
import React, { Fragment } from 'react';

return (
  <Fragment>
    <h1>A heading</h1>
    <p>A paragraph</p>
  </Fragment>
)
// OR if you don't import Fragment
return (
  <React.Fragment>
    <h1>A heading</h1>
    <p>A paragraph</p>
  </React.Fragment>
)
```

> Note that the short hand method does not accept attributes (**props**). You need to use `<Fragment>` if you want to pass that fragment any props.

## Conditional Expressions that result in Multiple Elements

- JSX supports conditional expressions using ternary and short circuit operators.

```jsx
const userLoggedIn = false;

return (
  <Fragment>
    {userLoggedIn ?
      <h1>Success!</h1>
      <p>You are logged in.</p>
    :
      <h1>Warning!</h1>
      <p>You are not logged in</p>
    }
  </Fragment>
)
```

> Will error out. The conditional express is returning TWO elements. It must ONLY return one.

We can wrap our conditional expression in a Fragment to fix this.

```jsx
const userLoggedIn = false;

return (
  <Fragment>
    {userLoggedIn ?
    <>      										// shorthand for <Fragment>
      <h1>Success!</h1>
      <p>You are logged in.</p>
    </>
    :
    <>      										// shorthand for <Fragment>
      <h1>Warning!</h1>
      <p>You are not logged in</p>
    </>
    }
  </Fragment>
)

//or

return (
	 <>
    {userLoggedIn ?
    <>
      <h1>Success!</h1>
      <p>You are logged in.</p>
    </>
    :
    <>
      <h1>Warning!</h1>
      <p>You are not logged in</p>
    </>
    }
  </>
)
```

## Exampling props.children, event handlers, Controlled Component

```jsx
import React, { useState } from 'react'
import ReactDOM from 'react-dom'
import './index.css'

const Button = (props) => {
  const { resetBtn } = props
  return <button onClick={resetBtn}>{props.children}</button>
}

const Application = () => {
  const [name, setName] = useState('')

  const reset = () => {
    console.log('reset')
    setName('')
  }

  return (
    <main>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Type your name"
      ></input>
      <Button resetBtn={reset}>Reset</Button>
      {name !== '' && <h1>Hello {name}</h1>}
    </main>
  )
}

ReactDOM.render(<Application />, document.getElementById('root'))
```

## Styling Components

- There are many ways to style components.

### CSS stylesheets (components.css)

- use when you have a complex style that you want to reuse.
- simple import the sheet `import './DottedBox.css'`.

```jsx
import React from 'react'
import './DottedBox.css'

const DottedBox = () => (
  <div className="DottedBox">
    <p className="DottedBox_content">Get started with CSS styling</p>
  </div>
)

export default DottedBox
```

Read more [here](https://create-react-app.dev/docs/adding-a-stylesheet/)

### Inline styles

- specified with an **object**
- **key** is the `camelCased` version of the (`fontSize`, `textAlign`)
- **value** is the style‚Äôs value, usually a `string`.

```jsx
import React from 'react'

const divStyle = {
  margin: '40px',
  border: '5px solid pink',
}
const pStyle = {
  fontSize: '15px',
  textAlign: 'center',
}

const Box = () => (
  <div style={divStyle}>
    <p style={pStyle}>Get started with inline style</p>
  </div>
)

export default Box
```

- We can create a **variable** that stores style properties and then pass it to the element like `style={nameOfvariable}`
  - Like above.
- We can also pass the styling **directly** `style={{color: 'pink'}}`

### CSS Modules

- CSS Module is a CSS file in which all **class names** and **animation names** are scoped **locally** by default.
- Similar to css we **import** css file `import styles './DashedBox.css'`
- we access to `className` as we access to **object**

```jsx
 :local(.container) {
   margin: 40px;
   border: 5px dashed pink;
 }
 :local(.content) {
   font-size: 15px;
   text-align: center;
 }
```

- Use `:local(.className)` when you use `create-react-app` because of webpack configurations

### Styled Components

- **Styled Components** is a library that allows us to create reusable styles.

```jsx
import React from 'react'
import styled from 'styled-components'

const Div = styled.div`
  margin: 40px;
  border: 5px outset pink;
  &:hover {
    background-color: yellow;
  }
`

const Paragraph = styled.p`
  font-size: 15px;
  text-align: center;
`

const OutsetBox = () => (
  <Div>
    <Paragraph>Get started with styled-components üíÖ</Paragraph>
  </Div>
)

export default OutsetBox
```

- First we need to install styled-components library: `npm install styled-components --save`
- Now we can create a variable by selecting a particular html element where we store our style keys `const Div = styled.htmlElemnet"color: pink"`
- Then we use the name of our variable as a wrapper `<Div></Div>` kind of react component

### Sass

- requires you to install `node-sass` library.
- rename any `.css` file to `.scss`

Read more [here](https://create-react-app.dev/docs/adding-a-sass-stylesheet/)

### BEM

- BEM is a methodology for naming HTML elements and CSS classes.

With BEM we have three types of CSS classes. The Block, the Element and the Modifier.

- **Block**:
  - Encapsulates a standalone entity that is meaningful on its own.
  - In our case this is the `.day-list`.
- **Element**:
  - An element that is tied to its block.
  - In our case this is the `.day-list__item`.
- **Modifier**:
  - An modification to a block or an element.
  - In our case this is `.day-list__item---selected` or `.day-list__item---full`.

We use combinations of these classes to define the different visual states an element can have.

```jsx
<li class="day-list__item">Default</li>
<li class="day-list__item day-list__item---selected">Selected</li>
<li class="day-list__item day-list__item---full">Full</li>
<li class="day-list__item day-list__item---selected day-list__item---full">Selected & Full</li>
```

One of the main things to notice about BEM is that it is not tied to the DOM structure.

The specificity is enforced through **naming** rather than **complex** selectors.

### Summary of CSS techniques

![css](https://s3-us-west-2.amazonaws.com/reactv2/figures/a523bbe3-3304-4006-9752-dae2936e1f30.png)
