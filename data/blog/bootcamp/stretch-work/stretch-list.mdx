---
title: Stretch
date: '2022-07-01'
tags: ['Stretch']
images: ['/static/images/postImages/d-s-chapman-aIgZHolF4Dg-unsplash.jpg']
draft: false
summary: List of all completed stretch assignments.
---

<TOCInline toc={props.toc} asDisclosure />

## obfuscate

Make `password.js` take in a single string as a command line argument and print out an obfuscated version of that password, using the rules defined below.

- Every "a" in the string should be replaced with a "4".
- Every "e" in the string should be replaced with a "3".
- Every "o" (oh) in the string should be replaced with a "0" (zero).
- Every "l" (el) in the string should be replaced with a "1" (one).

```js
const obfuscate = (password) => {
  password.forEach((item) => {
    console.log(
      item.replace(/\a/gi, '4').replace(/\e/gi, '3').replace(/\o/gi, '0').replace(/\l/gi, '1')
    )
  })
}

obfuscate(process.argv.slice(2))
```

## Flatten

`flatten` is a function which does something like this. Given an array with other arrays inside, it can flatten it into a single-level array.

```js
const flatten = (nested) => {
  const result = []
  return result.concat(...nested)
}

console.log(flatten([1, 2, [3, 4], 5, [6]]))
```

## Palindrome

```js
const isPalindrome = function (str) {
  let reversed = str.toLowerCase().replace(/\s/g, '').split('').reverse().join('')
  return str.toLowerCase().replace(/\s/g, '') === reversed
}

// Assertion Function
const assertPalindrome = function (word, expected) {
  console.log(`Testing isPalindrome(\"${word}\"):`)
  const actual = isPalindrome(word)
  if (actual === expected) {
    console.log('\x1b[32m%s\x1b[0m', `\tPASS âœ… function returned ${actual}\n`)
  } else {
    console.log(
      '\x1b[31m%s\x1b[0m',
      `\tFAIL ðŸ›‘ function returned ${actual} (expected ${expected})\n`
    )
  }
}

// TEST CODE
// These should all pass assertion, but they don't.
assertPalindrome('p', true)
assertPalindrome('racecar', true)
assertPalindrome('my gym', true)
assertPalindrome('foo', false)
assertPalindrome('fluff', false)
assertPalindrome('just some random words', false)

// Bonus / Stretch: Uncomment these tests and figure out why these are also failing
assertPalindrome('Kayak', true)
assertPalindrome('a santa at NASA', true)
```

## PrintInFrame

```js
const printInFrame = function (list) {
  list = list.split(' ')
  const longest = longestStr(list).length
  const border = repeat('*', longest + 4)

  console.log(border)
  for (const word of list) {
    console.log(`* ${word}${repeat(' ', longest - word.length + 1)}*`)
  }
  console.log(border)
}

const repeat = function (str, times) {
  let result = str

  for (let i = 0; i < times; i++) {
    result += str
  }

  return result
}

const longestStr = function (list) {
  let longest = list[0]

  for (const str of list) {
    if (str.length > longest.length) {
      longest = str
    }
  }

  return longest
}

// Test driver code, do not modify
printInFrame('May the force be with you')
printInFrame("Here's Johnny!")
printInFrame('Supercalifragalisticexpialadocious')
printInFrame('Lost, like tears in the rain')
```

## calculateDayInYear

The code defines a function calculateDayInYear which calculates the day of the year for a particular date string.

```js
function calculateDayInYear(date) {
  const splitDate = date.split('/')
  const year = Number(splitDate[0])
  const month = Number(splitDate[1])
  const day = Number(splitDate[2])

  const isLeapYear = function (year) {
    if (
      (isMultiple(year, 400) && isMultiple(year, 100)) ||
      (!isMultiple(year, 100) && isMultiple(year, 4))
    ) {
      return true
    }
    return false
  }

  const daysInFeb = function (year) {
    if (isLeapYear(year)) {
      return 29
    }
    return 28
  }

  const DAYS_IN_MONTH = [31, daysInFeb(year), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

  const validMonth = function (month) {
    return month && month >= 1 && month <= 12
  }

  const validDay = function (month, day) {
    return day && day >= 1 && day <= DAYS_IN_MONTH[month - 1]
  }

  //leap year is good
  const calculateDayNumber = function (month, day) {
    let dayNumber = 0
    for (let i = 0; i < month - 1; i++) {
      dayNumber += DAYS_IN_MONTH[i]
    }
    dayNumber += day
    return Number(dayNumber)
  }

  if (year && validMonth(month) && validDay(month, day)) {
    console.log(date, 'is day', calculateDayNumber(month, day), 'of the year', year)
    return calculateDayNumber(month, day)
  } else {
    console.log('Invalid date')
  }
}

const isMultiple = function (numerator, denominator) {
  return numerator % denominator === 0
}
/*
    Below are some simple tests!

    They run the function with a predetermined parameter and compare the output to the value we are expecting to get!

    The console.log will output either 'true' or 'false' based on whether or not the function
    returns a value that matched our expected value.

    You'll know your code works correctly when all of these tests return 'true'.
*/
console.log('Tests:')
console.log('---------------')
console.log(calculateDayInYear('1900/3/2') === 61)
console.log(calculateDayInYear('2000/3/2') === 62)
console.log(calculateDayInYear('2012/2/29') === 60)
console.log(calculateDayInYear('2015/12/31') === 365)
```

## calculateSalesTax

Given the following data, implement a function calculateSalesTax that calculates the total sales and total tax, grouped by company.

```js
const salesTaxRates = {
  AB: 0.05,
  BC: 0.12,
  SK: 0.1,
}

const companySalesData = [
  {
    name: 'Telus',
    province: 'BC',
    sales: [100, 200, 400],
  },
  {
    name: 'Bombardier',
    province: 'AB',
    sales: [80, 20, 10, 100, 90, 500],
  },
  {
    name: 'Telus',
    province: 'SK',
    sales: [500, 100],
  },
]

const calculateSalesTax = (salesData, taxRates) => {
  const result = {}

  for (let company of salesData) {
    const province = company.province
    const taxForCompany = taxRates[province]
    const totalSales = company.sales.reduce((acc, val) => {
      return acc + val
    }, 0)
    const totalTaxes = Math.round(totalSales * taxForCompany)

    if (result[company.name]) {
      let companyName = result[company.name]
      companyName.totalSales = companyName.totalSales + totalSales
      companyName.totalTaxes = companyName.totalTaxes + totalTaxes
    } else {
      result[company.name] = {
        totalSales: totalSales,
        totalTaxes: totalTaxes,
      }
    }
  }
  return result
}

const results = calculateSalesTax(companySalesData, salesTaxRates)
console.log(results)
```

## pythagorean

```js
const input = [
  { x: 3, y: 4 },
  { x: 12, y: 5 },
  { x: 8, y: 15 },
]
const result = input.map((item) => Math.sqrt(Math.pow(item.x, 2) + Math.pow(item.y, 2)))

console.log(result[0] === 5)
console.log(result[1] === 13)
console.log(result[2] === 17)
```

## studentSort

Say we have a list of students that we would like to sort in alphabetical order.

If students have the same name, then we prioritize the older student first.

```js
const students = [
  { id: 1, name: 'bruce', age: 40 },
  { id: 2, name: 'zoidberg', age: 22 },
  { id: 3, name: 'alex', age: 22 },
  { id: 4, name: 'alex', age: 30 },
]

const studentSort = (arr) => {
  for (let i = arr.length; i > 0; i--) {
    for (let j = 0; j < i - 1; j++) {
      if (arr[j].name === arr[j + 1].name) {
        if (arr[j].age > arr[j + 1].age) {
          let temp = arr[j]
          arr[j] = arr[j + 1]
          arr[j + 1] = temp
        }
      } else {
        if (arr[j].name > arr[j + 1].name) {
          let temp = arr[j]
          arr[j] = arr[j + 1]
          arr[j + 1] = temp
        }
      }
    }
  }
  return arr
}

console.log(studentSort(students))
```

## Music Library Problems

```js
const library = {
  tracks: {
    t01: {
      id: 't01',
      name: 'Code Monkey',
      artist: 'Jonathan Coulton',
      album: 'Thing a Week Three',
    },
    t02: { id: 't02', name: 'Model View Controller', artist: 'James Dempsey', album: 'WWDC 2003' },
    t03: { id: 't03', name: 'Four Thirty-Three', artist: 'John Cage', album: 'Woodstock 1952' },
  },
  playlists: {
    p01: { id: 'p01', name: 'Coding Music', tracks: ['t01', 't02'] },
    p02: { id: 'p02', name: 'Other Playlist', tracks: ['t03'] },
  },
}

/////////////////////////////
// FUNCTIONS TO IMPLEMENT:
/////////////////////////////

// prints a list of all playlists, in the form:
// p01: Coding Music - 2 tracks
// p02: Other Playlist - 1 tracks
const printPlaylists = (obj) => {
  let playlistsArr = Object.values(obj.playlists)

  for (let item of playlistsArr) {
    console.log(`${item.id}: ${item.name} - ${item.tracks.length} tracks`)
  }
}

// prints a list of all tracks, using the following format:
// t01: Code Monkey by Jonathan Coulton (Thing a Week Three)
// t02: Model View Controller by James Dempsey (WWDC 2003)
// t03: Four Thirty-Three by John Cage (Woodstock 1952)
const printTracks = (obj) => {
  let tracksListArr = Object.values(obj.tracks)

  for (let item of tracksListArr) {
    console.log(`${item.id}: ${item.name} by ${item.artist} (${item.album})`)
  }
}
//printTracks(library);

// prints a list of tracks for a given playlist, using the following format:
// p01: Coding Music - 2 tracks
// t01: Code Monkey by Jonathan Coulton (Thing a Week Three)
// t02: Model View Controller by James Dempsey (WWDC 2003)
const printPlaylist = (playlistId) => {
  let playlist = library.playlists[playlistId]
  console.log(`${playlist.id}: ${playlist.name} - ${playlist.tracks.length} tracks`)
  let trackDetails

  for (let trackId of playlist.tracks) {
    trackDetails = library.tracks[trackId]
    console.log(
      `${trackDetails.id}: ${trackDetails.name} by ${trackDetails.artist} (${trackDetails.album})`
    )
  }
}
//printPlaylist('p01');

// adds an existing track to an existing playlist
const addTrackToPlaylist = (trackId, playlistId) => {
  library.playlists[playlistId].tracks.push(trackId)
}

//addTrackToPlaylist('t99', 'p01')

// generates a unique id
// (already implemented: use this for addTrack and addPlaylist)
const generateUid = function () {
  return Math.floor((1 + Math.random()) * 0x10000)
    .toString(16)
    .substring(1)
}

// adds a track to the library
const addTrack = (name, artist, album) => {
  const generatedId = generateUid()

  library.tracks[generatedId] = {
    id: generatedId,
    name,
    artist,
    album,
  }
}

addTrack('Objects Rule the World', 'Infinite SyntaxError', 'Tears on My Keyboard')
addTrack('Objects Rule the World', 'Infinite SyntaxError', 'Test Album')
addTrack('Objects Rule the World', 'Test Artist', 'Tears on My Keyboard')
addTrack('Test Name', 'Infinite SyntaxError', 'Tears on My Keyboard')

// adds a playlist to the library
const addPlaylist = (name) => {
  const generatedId = generateUid()

  library.playlists[generatedId] = {
    id: generatedId,
    name,
    tracks: [],
  }
}
//addPlaylist('Coding on prod');

// STRETCH:
// given a query string string, prints a list of tracks
// where the name, artist or album contains the query string (case insensitive)
// tip: use "string".search("tri")
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search
const printSearchResults = (query) => {
  const tracksIdObj = Object.values(library.tracks)

  for (let track of tracksIdObj) {
    if (!track.name.search(query) || !track.artist.search(query) || !track.album.search(query)) {
      console.log(track)
    }
  }
}

printSearchResults('Test')
```

## sumItems - recursive

Should be able to accept nested arrays.

```js
// recursively sum all numbers in nested array
function sumItems(array) {
  let sum = 0
  // iterate through array
  for (let i = 0; i < array.length; i++) {
    // check to see if array[i] is an array
    if (Array.isArray(array[i])) {
      // if it is, call sumItems on array[i]
      // allows for nested arrays
      sum += sumItems(array[i])
    } else {
      // if it is not, add array[i] to sum
      sum += array[i]
    }
  }
  // return sum once all items in array have been iterated through
  return sum
}

module.exports = sumItems
```

## caesar cipher

- function to encrypt a string using caesar cipher
- takes in a string and an integer as arguments
- negative integers to shift left
- positive integers to shift right

```js
const encrypt = (string, shift) => {
  let result = ''
  // iterate through each character in the string
  for (let i = 0; i < string.length; i++) {
    let char = string[i]
    // if the character is a space, add it to the result right away
    if (char === ' ') {
      result += ' '
    } else {
      // get the character code of the character (97 - 122)
      let charCode = char.charCodeAt(0)
      let newCharCode = charCode + shift
      // if the new character code is greater than 122, subtract 26 from it
      if (newCharCode > 122) {
        newCharCode -= 26
      }
      // if the new character code is less than 97, add 26 to it
      if (newCharCode < 97) {
        newCharCode += 26
      }

      result += String.fromCharCode(newCharCode)
    }
  }
  return result
}

module.exports = { encrypt }
```

Tests:

```js
const assert = require('chai').assert
const { encrypt } = require('./caesar')

describe('caesar.encrypt', () => {
  // tip: try to make this single test pass first, before implementing the whole thing
  it('encrypts a single letter with a left shift of 3', () => {
    assert.equal(encrypt('e', -3), 'b')
  })

  // tip 2: then make this one pass, before handling all letters in the given string
  it('characters should wrap around the alphabet', () => {
    assert.equal(encrypt('b', -3), 'y')
  })

  it('encrypts the string "hello" to "ebiil" with a left shift of 3', () => {
    assert.equal(encrypt('hello', -3), 'ebiil')
  })

  it('encrypts a sentence "hello world" => "mjqqt btwqi", skips spaces (right shift of 5)', () => {
    assert.equal(encrypt('hello world', 5), 'mjqqt btwqi')
  })
})
```

### FindFriend

```js
const contacts = [
  {
    name: 'Laurel',
    phone: '123 456 7890',
    email: 'laurel@comics.com',
    friends: ['Hardy', 'Abbott', 'Costello'],
  },
  {
    name: 'Hardy',
    phone: '321 654 0987',
    email: 'hardy@hardyharhar.com',
    friends: ['Laurel', 'Buster'],
  },
  {
    name: 'Buster',
    phone: '987 654 3210',
    email: 'buster@keaton.ca',
    friends: ['Hardy'],
  },
  {
    name: 'Abbot',
    phone: '888 123 4567',
    email: 'abbott@whosonfirst.co',
    friends: ['Costello', 'Laurel'],
  },
  {
    name: 'Costello',
    phone: '767 676 7676',
    email: 'costello@imonfirst.co',
    friends: ['Abbott', 'Laurel'],
  },
]

// The first parameter is the contact data itself
// The second is the name of a contact, and
// The third parameter will be specifying the field (property) of the friend we want back.

const findFriend = (contacts, name, field) => {
  // Find the contact with the name specified
  const contact = contacts.find((contact) => contact.name === name)
  // case where contact is not in friends list
  if (!contact) return 'Not found'
  // find first friend that matches name
  const contactFriends = contact.friends[0]
  // iterate over arg1 till desired friend is found
  const friendDetails = contacts.find((contact) => contact.name === contactFriends)
  // create object to potentially return
  const result = {}
  // assign properties
  result['name'] = contactFriends
  result[field] = friendDetails[field]
  // if property does not exist
  if (!result[field]) return 'Not found'
  return result
}

// // console.log(findFriend(contacts, "Abbott", "phone"));
// // console.log(findFriend(contacts, "Buster", "email"));
// // console.log(findFriend(contacts, "Bob", "phone"));
// console.log(findFriend(contacts, "Costello", "birthday"));
```
