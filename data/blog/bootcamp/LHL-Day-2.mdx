---
title: Lighthouse Labs - Day 2
date: '2022-07-28'
tags: ['functions', 'errors']
images: ['/static/images/postImages/becomes-co-s_FHDDSVp1s-unsplash.jpg']
draft: false
summary: Rules of functions, scope, errors, Ccercion, and more.
---

<TOCInline toc={props.toc} asDisclosure />

# Summary

Day 2 of Lighthouse Labs! Today's lesson includes writing code incrementally, problem solving tips and basic git workflow (init -> add -> commit -> push). Additionally, we cover JavaScript specific concenpts such as debugging, pseudocode, and scope.

### Function Best Practices

1. Give your functions precise verb/action based names
2. Use `camelCasedNames` (like this one)
3. Properly indent the function code (two spaces)
4. Functions should focus on a single task: returning a value or causing a side effect. Break your function into additional smaller functions if you find it doing two or more things

- One single task could be to compute and return a value (eg: `zeroPad`)
- Another single task could be to perform a side effect such as logging a message to the screen (eg: `printFarmInventory`)

#### Function Best Practices - Rolling Dice

Write a program that takes a single parameter from the command line, a number, and rolls that many six-sided dice.

```
> node dice-roller.js 3
Rolled 3 dice: 2, 6, 5
```

Solution:

```js
const rollDice = (num) => {
  let result = []
  for (let i = 0; i < num; i++) {
    // generate random number between 1 - 6
    let randomNum = Math.floor(Math.random() * 6)
    result.push(randomNum)
  }
  return console.log(`Rolled ${num} dice: ${result.join(', ')}`)
}

rollDice(process.argv.slice(2))
```

### Scope in JavaScript

#### Global vs Local Scope

Globally-scoped variables are available to all functions, everywhere in out code. Locally-scoped variables are only available within the function they are defined in.

For example:

```js
let myGlobalVar = 'global'

const printMyVars = function () {
  let myLocalVar = 'local'
  console.log('-- Inside printMyVars --')
  console.log('myLocalVar is:', myLocalVar)
  console.log('myGlobalVar is:', myGlobalVar)
}

printMyVars()

console.log('-- Outside of printMyVars now --')
console.log(myLocalVar)
```

> Here we will get an error. The variable `myLocalVar` is not defined because it is locally scoped.

Scoping can result in variables being **overwriten**.

```js
let myVar = 'global'

const myFunction = function () {
  let myVar = 'local'

  console.log('inside myFunction, myVar is:', myVar) // "local"
}

myFunction()

console.log('outside myFunction, myVar is:', myVar) // "global"
```

> Inside out function the local spode will take precedence over the global scope, printing `local` instead of `global`. However, outside of the function, the global scope will be used, printing `global`.

#### One more Rule: Pass in the Data Needed

It is idea to try and **avoid passing in globally scoped data**. If a function needs some information/data, it should be passed in as a **parameter**, making it available within the functions inner scope.

Example:

```js
const person = 'Martha'

// BAD
const sayHelloBadly = function () {
  console.log(`Howdy, ${person}`)
}
sayHelloBadly() // Works, but not ideal!

// GOOD
const sayHelloGoodly = function (name) {
  console.log(`Howdy, ${name}`)
}
sayHelloGoodly(person)
```

But why do we care? Why do we want to avoid passing in globally scoped data?

Because functions that take in parameters are more **reusable**. They are not depenedent on their outer scope. They can be used in different ways, and they can be passed in different data.

#### Rules of functions summary

1. Give your functions precise verb/action based names
1. Use `camelCasedNames` (like this one)
1. Properly indent the function code
1. Functions should focus on a single task: returning a value or causing a side effect. Break your function into additional smaller functions if you find it doing two or more things

- One single task could be to compute and return a value (eg: `zeroPad`)
- Another single task could be to perform a side effect such as logging a message to the screen (eg: `printFarmInventory`)

1. Data needed by Functions should be passed in as parameters/arguments (i.e. local scope) instead of being accessed 1. directly

# Understanding Errors

### Syntax Erros

Errors are a **signal** that something went wrong. They are used to communicate to the developer what went wrong.

Consider the following:

```js
const rank = "Imperator";
const name = "Furiosa";

console.log(rank name);
```

Returns:

```
node syntax-error.js
/vagrant/focal/syntax-error.js:4
console.log(rank name);
                 ^^^^
SyntaxError: Unexpected identifier
    at exports.runInThisContext (vm.js:73:16)
    at Module._compile (module.js:443:25)
    at Object.Module._extensions..js (module.js:478:10)
    at Module.load (module.js:355:32)
    at Function.Module._load (module.js:310:12)
    at Function.Module.runMain (module.js:501:10)
    at startup (node.js:129:16)
    at node.js:814:3
```

This tells us that the error happened in a file called `/vagrant/focal/syntax-error.js`, but more importantly, the `:4` on the end of the file name tells us the error was thrown by line **4** in this file.

Looking at our code, we see line 4 has the following: `console.log(rank name);`.

Our error gives us another hint - we are leading with a `SyntaxError`. There appears to be something wrong with `name`, which javascript is calling `Unexpected identifier`.

The issue here is that the variables are not separated by a comma (`,`) and the error is thrown in the middle of the line.

Solution: `console.log(rank, name);`

### Stack Traces

Stack traces are the **traceback** of the error.

When an error is thrown, the stack trace is a list of all the functions that were called before the error was thrown.

```
    at exports.runInThisContext (vm.js:73:16)
    at Module._compile (module.js:443:25)
    at Object.Module._extensions..js (module.js:478:10)
    at Module.load (module.js:355:32)
    at Function.Module._load (module.js:310:12)
    at Function.Module.runMain (module.js:501:10)
    at startup (node.js:129:16)
    at node.js:814:3
```

This will be covered in a later section.

### Tricky Syntax Errors

Consider the following:

```js
if (5 > 10) {
  console.log("Impossible!");

console.log("Phew, logical fallacies avoided.");
```

We expect to see the following output:

```
Phew, logical fallacies avoided.
```

But we get this instead:

```
/vagrant/focal/syntax-error2.js:6
});
 ^
SyntaxError: Unexpected token )
    at exports.runInThisContext (vm.js:73:16)
    at Module._compile (module.js:443:25)
    at Object.Module._extensions..js (module.js:478:10)
    at Module.load (module.js:355:32)
    at Function.Module._load (module.js:310:12)
    at Function.Module.runMain (module.js:501:10)
    at startup (node.js:129:16)
    at node.js:814:3
```

For one, there is no line 6 in our code. We only wrote 4 lines.

We also have a new type of syntaxError: `Unexpected token`.

`Unexpected token` errors occur when JavaScript **expected** something that wasn't there, which frequently means we're missing a parenthesis, bracket or curly brace. In our case, we're missing a `}`.

```js
if (5 > 10) {
  console.log('Impossible!')
}

console.log('Phew, logical fallacies avoided.')
```

### Reference Errors

Consider the following:

```js
var firstName = 'Jane'
var lastName = 'Doe'

console.log(firstName, lasName)
```

However, it does not work. We get the following error:

```
node reference-error.js
/vagrant/focal/reference-error.js:4
console.log(firstName, lasName);
                       ^
ReferenceError: lasName is not defined
    at Object.<anonymous> (/vagrant/focal/reference-error.js:4:24)
    at Module._compile (module.js:460:26)
    at Object.Module._extensions..js (module.js:478:10)
    at Module.load (module.js:355:32)
    at Function.Module._load (module.js:310:12)
    at Function.Module.runMain (module.js:501:10)
    at startup (node.js:129:16)
    at node.js:814:3
```

Let's begin by reading the error message **line by line**.

```
/vagrant/focal/reference-error.js:4
```

> Indicates an issue on line 4.

Something went wrong with `lasName`. Node tells us that it's **not defined**. `ReferenceErrors` are also common errors we see in day-to-day development, and they occur when we're trying to use the value of an **undefined variable**. In our case, this happened because we misspelled `lastName`.

```js
var firstName = 'Jane'
var lastName = 'Doe'

console.log(firstName, lastName) // Jane Doe
```

### Type Errors

Let's quiet down and convert all capital letters into lowercase.

```js
var favouriteMeal = 'BREAKFAST'

console.log(favouriteMeal.toLower())
```

But we get an error:

```
node type-error.js
/vagrant/focal/type-error.js:3
console.log(favouriteMeal.toLower());
                          ^
TypeError: undefined is not a function
    at Object.<anonymous> (/vagrant/focal/type-error.js:3:27)
    at Module._compile (module.js:460:26)
    at Object.Module._extensions..js (module.js:478:10)
    at Module.load (module.js:355:32)
    at Function.Module._load (module.js:310:12)
    at Function.Module.runMain (module.js:501:10)
    at startup (node.js:129:16)
    at node.js:814:3
```

So our error tells us we have an issue on line 3, something to do with `toLower`. It tells us a function is `undefined` when we tried to run the method.

We only have two functions here, `console.log` and `toLower`. After a quick Google search we learn that the method we wanted to use is `toLowerCase()`.

### Coercion and Truthy/Falsey

The `===` does not only compare two values, but also the **type** of those values.

Consider this example:

```js
23 === '23' // false

23 == '23' // true
```

Using the `===` operator, we can see that the two values are not the same. They differ in type.

In this case, `==` returns True. Before performing any sort of comparison, the `==` operator will attempt to force the two values to be of the same type, if possible. This is called **type coercion**, and it can really mess up your expected results if you're not careful.

It's better to use tripple equals (`===`) instead of double equals (`==`).

#### Truthy/Falsey

Comparisons of two values will return either True or False. But some unexpected results can be caused by using the `==` operator.

```
0 == false
```

In JavaScript, everything has an inherent Boolean value (a Truthy or Falsey value).

In this case, even though `0` is a Number, it also holds a **Falsey** value.

Most things are considered **truthy**, except:

| Value       | Result | Description                          |
| ----------- | ------ | ------------------------------------ |
| `false`     | False  |                                      |
| `null`      | False  | is an empty value                    |
| `undefined` | False  | Is an object that has not be defined |
| `0`         | False  | Is a Number with a value of 0        |
| `''`        | False  | Is a String with a value of ''       |
| `NaN`       | False  | Is a Number with a value of NaN      |
