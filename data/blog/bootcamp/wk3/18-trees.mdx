---
title: Trees
date: '2022-07-15'
tags: ['trees', 'data structures']
images: ['/static/images/postImages/tree.jpeg']
draft: false
summary: Learn about trees and how they can be used to store data.
---

<TOCInline toc={props.toc} asDisclosure />

Every app require some sort of data. Sometimes we store data in a single way, such as a string, number, or boolean.

```js
let myString = 'Hello World'
let myNumber = 42
let myBoolean = true
```

Sometimes we need to store data in a more complex way, such as an array or object.

```js
let myArray = [1, 2, 3, 4, 5]
let myObject = {
  name: 'John',
  age: 30,
  isMarried: true,
}
```

Arrays are great to store a list of data, especially when we want to store data in a specific order.

Objects are great when we want to store data in a specific way, but we don't want to store data in a specific order. Objects allow for quick and easy data lookup using they key.

Both arrays and objects are very common in most programming languages. However, there are many other ways of storing and organizing data.

We will look into a commonly used data structure called a **tree**.

## Tree Basics

<div className="my-1 px-2 w-full">![nodes](/static/images/individualBlogPostImages/node.png)</div>-
each circle is a _node_ - nodes represent a key entity and contain data about the entity. - each
connection between nodes is called an _edge_

- edges represent a connection between two nodes.

- the top of the tree is called the _root_
- nodes at the very bottom are called _leafs_
  - leafs do **not** have any children

<div className="my-1 px-2 w-full">
  ![root and children](/static/images/individualBlogPostImages/root.png)
</div>

- Every node expect for the root node has a _parent node_

- Every node that is **not** a leaf has a _child node_

<div className="my-1 px-2 w-full">
  ![chilren](/static/images/individualBlogPostImages/children.png)
</div>
- children with the same parent are called _siblings_

<div className="my-1 px-2 w-full">
  ![siblings](/static/images/individualBlogPostImages/siblings.png)
</div>

### Tree Example

Imagine we have a company and need to be able to determine the following:

1. Who an employee is reporting to (boss).
2. The total number of people an employee supervises.
3. How many people there are between an employee and the CEO.
4. If two employees share the same boss.

- Each node in this tree is an Employee.
- Every Employee can have many subordinates.
- Every Employee, apart from the CEO, has one boss.

```js
class Employee {
  constructor(name, title, salary) {
    this.name = name
    this.title = title
    this.salary = salary
    this.boss = null
    this.subordinates = []
  }
}
```

> Here we have created an Employee class.

Creating the root and nodes below:

```js
// root
const ada = new Employee('Ada', 'CEO', 3000000.0)

// employees
const craig = new Employee('Craig', 'VP Software', 1000000)
const arvinder = new Employee('Arvinder', 'Chief Design Officer', 1000000)
const angela = new Employee('Angela', 'VP Retail', 1000000)
const phil = new Employee('Phil', 'VP Marketing', 1000000)
```

So far we have 5 nodes, however, none of them are connected to each other. We can modify our class to make this happen by adding a function which pushes the employee to the boss's subordinates array.

```js
class Employee {
  constructor(name, title, salary) {
    this.name = name
    this.title = title
    this.salary = salary
    this.boss = null
    this.subordinates = []
  }

  addSubordinate(subordinate) {
    this.subordinates.push(subordinate)
    subordinate.boss = this
  }
}

// start adding subordinates to the CEO
ada.addSubordinate(craig)
ada.addSubordinate(arvinder)
ada.addSubordinate(angela)
ada.addSubordinate(phil)
```

<div className="my-1 px-2 w-full">
  ![durian tree first level](/static/images/individualBlogPostImages/durian-tree.png)
</div>
We can continue adding levels to our tree to include all the employees, and use the `addSubordinate`
function to add subordinates to the employees.

Recall our original questions:

1. Who an employee is reporting to (boss).
2. The total number of people an employee supervises.
3. How many people there are between an employee and the CEO.
4. If two employees share the same boss.

We can create methods to answer these questions.

1. We can get the boss of an employee by using the nodes `boss` property like so:

```js
employee.boss // => returns the boss of the employee
```

2. We can get the total number of subordinates an employee has by using the nodes `subordinates` property like so:

```js
get numberOfSubordinates(employee) {
  return employee.subordinates.length
}
```

3. We can get the number of people between an employee and the CEO like so:

```js
  get numberOfPeopleToCEO() {
    let numberOfPeople = 0;
    let currentEmployee = this;
    while (currentEmployee.boss) {
      numberOfPeople++;
      currentEmployee = currentEmployee.boss;
    }
    return numberOfPeople;
  }
```

4. Method to return `true` is two people share the same boss. `false` otherwise.

```js
  hasSameBoss(employee) {
    return this.boss === employee.boss;
  }
```

All together:

```js
class Employee {
  constructor(name, title, salary) {
    this.name = name
    this.title = title
    this.salary = salary
    this.boss = null
    this.subordinates = []
  }

  addSubordinate(subordinate) {
    this.subordinates.push(subordinate)
    subordinate.boss = this
  }

  get boss() {
    return this.boss
  }

  get numberOfSubordinates() {
    return this.subordinates.length
  }

  get numberOfPeopleToCEO() {
    let numberOfPeople = 0
    let currentEmployee = this
    while (currentEmployee.boss) {
      numberOfPeople++
      currentEmployee = currentEmployee.boss
    }
    return numberOfPeople
  }

  SameBoss(employee) {
    return this.boss === employee.boss
  }
}

/////////// test this out

// root
const ada = new Employee('Ada', 'CEO', 3000000.0)

// employees
const craig = new Employee('Craig', 'VP Software', 1000000)
const arvinder = new Employee('Arvinder', 'Chief Design Officer', 1000000)
const angela = new Employee('Angela', 'VP Retail', 1000000)
const phil = new Employee('Phil', 'VP Marketing', 1000000)

ada.addSubordinate(craig)
ada.addSubordinate(arvinder)
ada.addSubordinate(angela)
ada.addSubordinate(phil)

console.log(craig.boss) // ada object
console.log(craig.numberOfSubordinates) // 0
console.log(craig.numberOfPeopleToCEO) // 1
```

### Tree Summary

Trees are good for representing data in a **hierarchical relationship**.

We can build a tree as long as we have a node that defines:

- the parent
- its children (if it has them)
- data about the node

For the example above...

|   Node   |      Employee       |
| :------: | :-----------------: |
|  parent  |        boss         |
| children |    subordinates     |
|   data   | name, title, salary |

We defined this within our Employee class, inside of the `constructor` function.

```js
class Employee {
  constructor(name, title, salary) {
    this.name = name // DATA
    this.title = title // DATA
    this.salary = salary // DATA
    this.boss = null // PARENT
    this.subordinates = [] // CHILDREN
  }
  // ...
}
```

#### Other Examples

**Browser DOM**

|   Node   |        HTML Element         |
| :------: | :-------------------------: |
|  parent  |       Parent Element        |
| children |       Child Elements        |
|   data   | attributes (id, class, etc) |

## Tree Traversal

When we want to access the items in an array, we can just use a for loop. But how do we do this with nodes in a tree?

This involves traversing the tree.

Traversing rhough a tree's nodes is similar to looping through items in an array. We can go through the entire tree and visit every node or just each node underneath another specific node.

## Breadth-first traversal:

- we check the nodes closest to the root first
- visit all children of a node before moving on to the next node
- once an entire level of the tree is visited, we move on to the next level
- we start traversing through every node, **row by row**, until we find it
- Breadth first traversal will always visit the nodes closest to the root node before moving on to the nodes that are farther away.
- this is called breadth-first traversal

We check in this order:

<div className="my-1 px-2 w-full">![bfs](/static/images/individualBlogPostImages/bfs.png)</div>

<div className="my-1 px-2 w-full">
  ![bfs again](/static/images/individualBlogPostImages/bfs2.png)
</div>

## Depth First Traversal:

- We try to visit each leaf before moving on to the next node
- We visit an entire path down to a leaf before moving on to the next path
- Starts at the root
- Then move the nodes **first child.**
- Once the node has no more childnre, we move on to the next **sibling**.
- Once the node has **no children** and **no siblings**, we move back to the **parents next sibling**.

<div className="my-1 px-2 w-full">
  ![bfs again](/static/images/individualBlogPostImages/dfs.png)
</div>

<div className="my-1 px-2 w-full">
  ![bfs again](/static/images/individualBlogPostImages/dfs1.png)
</div>

<div className="my-1 px-2 w-full">
  ![bfs again](/static/images/individualBlogPostImages/dfs2.png)
</div>

## Implementation

Trees are essentially just composed of subtrees. We can use recursion to traverse the tree.

### Depth First Search (DFS)

1. visit the root note
2. get the first unvisited child cub-tree of the current node
3. do step 1 with the sub-tree

```
traverse tree:

  visit the root of the tree
  let subTree = the first unvisited child sub-tree of the root node

  recursive case:
    is there's a subTree, traverse subTree.
  base case:
    if there's no subTree, do nothing
```

Code:

```js
class Node {
  constructor(data) {
    this.data = data
    this.parent = null
    this.children = []
  }

  depthFirstTraversal() {
    console.log(this) // 1

    for (const childNode of this.children) {
      childNode.depthFirstTraversal() // 2
    }
  }
}
```

1. Visit the current node. In this case, we're just printing out the data.
2. Loop through every child of the current node and repeat the first step with that node.

#### DFS Tree traversal Example - Durian Tree

Create a method to find every single employee under Ada, that makes over $418,401 a year.

```js
class Employee {
  constructor(name, title, salary) {
    this.name = name
    this.title = title
    this.salary = salary
    this.boss = null
    this.subordinates = []
  }

  /// ... old code ...

  // our new function  // DFS example
  employeesThatMakeOver(amount) {
    let employees = [] // 1

    if (this.salary > amount) {
      employees.push(this) // 2
    }

    for (const subordinate of this.subordinates) {
      const subordinatesThatMakeOver = subordinate.employeesThatMakeOver(amount) // 3
      employees = employees.concat(subordinatesThatMakeOver)
    }

    return employees
  }
}

// root
const ada = new Employee('Ada', 'CEO', 3000000.0)

// employees
const craig = new Employee('Craig', 'VP Software', 1000000)
const arvinder = new Employee('Arvinder', 'Chief Design Officer', 1000000)
const angela = new Employee('Angela', 'VP Retail', 1000000)
const phil = new Employee('Phil', 'VP Marketing', 1000000)

ada.addSubordinate(craig)
ada.addSubordinate(arvinder)
ada.addSubordinate(angela)
ada.addSubordinate(phil)
```

1. Create a new employees array to hold every employee that makes over the specified amount.
2. If the current employee makes over that amount, add them to the array.
3. Call this method on all of the current employee's subordinates and combine their results with the current results.

We can call this method on the root node of the tree.

```js
let wealthyEmployees = ada.employeesThatMakeOver(418401)
```

---

Write a method that will count the total number of employees **under a certain employee**, including that employee.

This will let us calculate the total number of people in a certain department.

```js
class Employee {
  // ... prev code here

  // recursively call the function on each subordinate
  get totalEmployees() {
    let totalEmployees = 1 // 1

    for (const subordinate of this.subordinates) {
      totalEmployees += subordinate.totalEmployees // 2
    }

    return totalEmployees
  }
}

// root
const ada = new Employee('Ada', 'CEO', 3000000.0)

// employees
const craig = new Employee('Craig', 'VP Software', 1000000)
const arvinder = new Employee('Arvinder', 'Chief Design Officer', 1000000)
const angela = new Employee('Angela', 'VP Retail', 1000000)
const phil = new Employee('Phil', 'VP Marketing', 1000000)

const curtis = new Employee('Curtis', 'Dev', 1)

ada.addSubordinate(craig)
ada.addSubordinate(arvinder)
ada.addSubordinate(angela)
ada.addSubordinate(phil)

phil.addSubordinate(curtis)

let wealthyEmployees = ada.employeesThatMakeOver(418401)

console.log(wealthyEmployees) // very long list of employee nodes
console.log(ada.totalEmployees) // 5
console.log(craig.totalEmployees) // 1
console.log(phil.totalEmployees) // 2
```

### vampire examples

[see repo for full code and tests](https://github.com/Cwarcup/vampr-js)

```js
class Vampire {
  constructor(name, yearConverted) {
    this.name = name
    this.yearConverted = yearConverted
    this.offspring = []
    this.creator = null
  }

  /** Simple tree methods **/

  // Adds the vampire as an offspring of this vampire
  addOffspring(vampire) {
    vampire.creator = this
    this.offspring.push(vampire)
  }

  // Returns the total number of vampires created by that vampire
  get numberOfOffspring() {
    return this.offspring.length
  }

  // Returns the number of vampires away from the original vampire this vampire is
  get numberOfVampiresFromOriginal() {
    let totalToOriginal = 0
    let current = this

    while (current.creator) {
      totalToOriginal++
      current = current.creator
    }
    return totalToOriginal
  }

  // Returns true if this vampire is more senior than the other vampire. (Who is closer to the original vampire)
  isMoreSeniorThan(vampire) {
    return vampire.numberOfVampiresFromOriginal > this.numberOfVampiresFromOriginal
  }

  // Returns the vampire object with that name, or null if no vampire exists with that name
  vampireWithName(name) {
    if (this.name === name) return this

    // if not found, search offspring
    for (let next of this.offspring) {
      // assign result to variable so it can be returned if found
      let find = next.vampireWithName(name)
      if (find) return find
    }

    return null
  }

  // Returns the total number of vampires that exist
  get totalDescendents() {
    let total = 0

    for (let next of this.offspring) {
      total++
      total += next.totalDescendents
    }
    return total
  }

  // Returns an array of all the vampires that were converted after 1980
  get allMillennialVampires() {
    let result = []

    // condition to push into arr
    if (this.yearConverted > 1980) {
      result.push(this)
    }

    // recursive
    for (let next of this.offspring) {
      const vamps = next.allMillennialVampires
      result = result.concat(vamps)
    }
    return result
  }
}
```
