---
title: Promises
date: '2022-07-07'
tags: ['promises', 'json']
images: ['/static/images/postImages/andrew-petrov-hopnkQoC0dg-unsplash.jpg']
draft: false
summary: At the end of the day, promises are a way to make sure that a function is called at a certain time. They are a common pattern to help us manage asynchronous code and callbacks.
---

<TOCInline toc={props.toc} asDisclosure />

A `Promise` is an object that represents a value that may be available now, or in the future, or never. The value is not necessarily available yet, but it will be eventually. This allows us to write code that is asynchronous, and handle the value when it is available.

Compared to synchronous code which returns a value immediately, asynchronous code returns a `Promise` that may not be available yet.

Promises can take one of three states:

- `pending`: The initial state of a promise. The promise is waiting for some action to happen.
- `fulfilled`: The promise has been resolved, and the value is available.
- `rejected`: The promise has been rejected (error), and the reason for rejection is available.

When either of these states has been reached, the result is queued up by a promises `then` method.

> The `then` method takes a callback function, which is called when the promise is in the `fulfilled` or `rejected` state.

![promise .then and .catch()](../../../public/static/images/individualBlogPostImages/promises.png)

Promises can be returned by either the [`.then()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) or [`.catch()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch) methods.

Before we go deeper, let's take a look [JSON](https://www.json.org/json-en.html).

# JSON

JSON is a data format that is used to store data in a simple, human-readable format.

It is composed of two main parts:

- A collection of key-value pairs.
- An order list of values.

An object encoded using JSON looks like the following:

```json
{
  "name": "John",
  "age": 30,
  "cars": ["Ford", "BMW", "Fiat"],
  "address": {
    "street": "Main street",
    "city": "New York"
  }
}
```

- **keys** are always wrapped in double quotes `" "`.
- The value of a key can be any type of data.

## Serialization

_Serialization_ is the process of converting a data structure or object into a string. It can then be passed between computers.

The opposite of serialization would look like going from a `string` -> `OBject`. This process is known as _deserialization_.

More on JSON on MDN: [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON)

```bash
> const jsonString = '{"a":1, "b":2, "foo":"bar"}'
undefined

> const obj = JSON.parse(jsonString)
undefined

> obj
{ a: 1, b: 2, foo: 'bar' }

> const string = JSON.stringify(obj)
undefined

> string
'{"a":1,"b":2,"foo":"bar"}'

> delete obj.foo
true

> obj
{ a: 1, b: 2 }
```

### `JSON.stringify()`

Returns a string containing the JSON representation of the object.

### `JSON.parse()`

Parses a string as JSON and returns the resulting JavaScript object.

## JSON Media Type

When we sent data using HTTP requests/responses, the Media Type `application/json` was used.

> "A media type (also known as a Multipurpose Internet Mail Extensions or MIME type) indicates the nature and format of a document, file, or assortment of bytes." - [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)

In comparison, the Media Type for HTML is `text/html`.

The Media Type is set in the `Content-Type` **header** of the HTTP response.

# What is an API?

Application Programming Interface (API) is a set of methods that allow us to interact with a resource.

# Callback waterfall - callback hell problem

Refer back to the profileGenerater app: [here](https://github.com/Cwarcup/profile_generator/blob/eef20534794f673462e75b3ef18fb7921c6476b3/survey.js)

```js
const readline = require('readline')

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

const answers = []

rl.question("What's your name? Nicknames are also acceptable :) ", (answer1) => {
  console.log(`${answer1}, cool. I like that.`)
  answers.push(answer1)
  rl.question("What's an activity you like doing? ", (answer2) => {
    answers.push(answer2)
    rl.question(`What do you listen to while ${answer2}? `, (answer3) => {
      answers.push(answer3)
      rl.question(`Which meal is your favourite (eg: dinner, brunch, etc.)? `, (answer4) => {
        answers.push(answer4)
        rl.question(`What's your favourite thing to eat for ${answer4}? `, (answer5) => {
          answers.push(answer5)
          rl.question(`Which sport is your absolute favourite? `, (answer6) => {
            answers.push(answer6)
            rl.question(
              `What is your superpower? In a few words, tell us what you are amazing at! `,
              (answer7) => {
                answers.push(answer7)
                rl.close()
                const name = answer[0]
                const activity = answer[1]
                const music = answer[2]
                const meal = answer[3]
                const food = answer[4]
                const sport = answer[5]
                const superpower = answer[6]
              }
            )
          })
        })
      })
    })
  })
})
```

`answer1` is a variable that stores the user's name. It stores all the remaining answers in an array. The second question does the same thing. It is a callback within a callback. And so on and so on.

This is a problem that we can solve by using promises.

Promises version of the same code:

```js
// see notes to be sent out
// .then
```

- using `readline-promise` to read the user's input
- Users `questionAsync()` method to get the user's input

## Intro to Promises Examples

see notes for promise generator. Update at the end of the week.

# Error Handling with Promises (and callbacks)

see errors files. Update at the end of the week.

## Promise.all

The whole point of async is to do multitasking well.

Here we have four promises, all with different lengths of time for the duration (using setTimeout).

The event loop can launch code that will run in a multi-tasking fashion.

This is useful when you have multiple asynchronous tasks that need to be completed in order to render some calculation.

---

# Applicable Repositories

- [json_the_cat](https://github.com/Cwarcup/json_the_cat)
- [iss_spotter](https://github.com/Cwarcup/iss_spotter)

## Example

```js
let creditLimit = 50

/*
 * Input: number of dollars to loan out
 * Returns: Promise of loan which may or may not fulfill, based on remaining credit.
 * If creditLimit is less than the requested amount, only the remaining limit is loaned out, otherwise the full amount is loaned out. If $0 remain in the limit, the loan request is rejected (error!).
 */

const loanOut = (amount) => {
  return new Promise((resolve, reject) => {
    if (creditLimit <= 0) {
      reject('Insufficient funds')
    } else if (creditLimit < amount) {
      let remaining = creditLimit
      creditLimit = 0
      resolve(remaining)
    } else {
      creditLimit -= amount
      resolve(amount)
    }
  })
}

console.log('Asking for $150, which should be okay ...')
loanOut(150)
  .then((amountReceived) => {
    console.log(
      `\t-> I got $${amountReceived} loan from the bank! Remaining Credit Limit: $${creditLimit}`
    )
  })
  .catch((err) => {
    console.log(`\t-> Error: ${err}!`)
  })
```
