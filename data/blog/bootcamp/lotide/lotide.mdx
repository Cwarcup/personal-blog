---
title: lotide - Utility Library
date: '2022-08-03'
tags: ['lotide', 'Library']
images: ['/static/images/postImages/robin-spielmann-TUiNzx1vMBM-unsplash.jpg']
draft: false
summary: Utility library, similar to lodash.
---

<TOCInline toc={props.toc} asDisclosure />

## Lotide methods

Here are some methods we added to our lotide library:

### assertArraysEqual

Implement assertArraysEqual which will take in two arrays and console.log an appropriate message to the console.

```js
// takes in two arrays and returns true or false, based on a perfect match.
const eqArrays = (arr1, arr2) => {
  if (arr1.length !== arr2.length) {
    return false
  }
  for (let i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i]) {
      return false
    }
  }
  return true
}

const assertArraysEqual = (actual, expected) => {
  if (eqArrays(actual, expected)) {
    console.log(`✅ Assertion Passed: [${actual}] === [${expected}]`)
  } else {
    console.log(`❌ Assertion Failed: [${actual}] !== [${expected}]`)
  }
}
```

### eqArray recursive

```js
// recursive function to check if two objects are equal
const eqArrays = (arr1, arr2) => {
  // base case
  if (arr1.length !== arr2.length) {
    return false
  }

  for (let i = 0; i < arr1.length; i++) {
    // check if both elements are arrays
    if (Array.isArray(arr1[i]) && Array.isArray(arr2[i])) {
      if (!eqArrays(arr1[i], arr2[i])) {
        // if they are arrays, call the eqArrays function
        return false
      }
      // if they are not arrays, this condition
    } else if (arr1[i] !== arr2[i]) {
      // check if characters are equal
      return false
    }
  }
  // if all elements are equal, return true
  return true
}
```

### without

Implement `without` which will return a subset of a given array, removing unwanted elements.

This function should take in a `source` array and a `itemsToRemove` array. It should return a new array with only those elements from source that are not present in the itemsToRemove array.

Example:

```js
without([1, 2, 3], [1]) // => [2, 3]
without(['1', '2', '3'], [1, 2, '3']) // => ["1", "2"]
```

```js
const without = (arr, itemsToRemove) => {
  // empty array to store chars that pass condition
  let result = []

  while (arr.length > 0) {
    // remove first item in array
    let temp = arr.shift()

    // determine if temp variable is found in the itemsToRemove array
    if (!itemsToRemove.includes(temp)) {
      // if not item is not found, push temp to result array
      result.push(temp)
    }
  }
  return result
}

const withoutResult = without(['1', '2', '3'], [1, 2, '3'])
assertArraysEqual(withoutResult, ['1', '2']) // ✅ Assertion Passed: [1,2] === [1,2]
```

However, this results in the original array being mutated! This is caused by the fact that the `shift` method mutates the array.

We can fix this by using a for-loop to iterate over the array.

```js
const without = (arr, itemsToRemove) => {
  // empty array to store chars that pass condition
  let result = []

  for (let i = 0; i < arr.length; i++) {
    // remove first item in array
    let temp = arr[i]

    // determine if temp variable is found in the itemsToRemove array
    if (!itemsToRemove.includes(temp)) {
      // if not item is not found, push temp to result array
      result.push(temp)
    }
  }
  return result
}
```

### middle

Implement `middle` which will take in an array and return the middle-most element(s) of the given array.

The `middle` function should return an array with only the middle element(s) of the provided array. This means that the length of the returned elements could vary.

- For arrays with **one** or **two elements**, there is no middle. Return an empty array.

```js
middle([1]) // => []
middle([1, 2]) // => []
```

- For arrays with **odd** number of elements, an array containing a single middle element should be returned.

```js
middle([1, 2, 3]) // => [2]
middle([1, 2, 3, 4, 5]) // => [3]
```

- For arrays with an even number of elements, an array containing the two elements in the middle should be returned

```js
middle([1, 2, 3, 4]) // => [2, 3]
middle([1, 2, 3, 4, 5, 6]) // => [3, 4]
```

Possible Solution:

```js
const middle = (arr) => {
  // edge case when arr has less than 3 items
  if (arr.length < 3) {
    return []
  }

  // get middle index of array
  const middleIndex = Math.floor(arr.length / 2)

  // if true (1), return first
  // if false (even length) (0), return second option
  return arr.length % 2 ? arr[middleIndex] : [arr[middleIndex - 1], arr[middleIndex]]
}

// test cases
console.log(middle([1])) // => []
console.log(middle([1, 2])) // => []
console.log(middle([1, 2, 3])) // => [2]
console.log(middle([1, 2, 3, 4, 5])) // => [3]
console.log(middle([1, 2, 3, 4])) // => [2, 3]
console.log(middle([1, 2, 3, 4, 5, 6])) // => [3, 4]
```

### countOnly

countOnly will be given an array and an object. It will return an object containing counts of everything that the input object listed.

Only keys which have a truthy value should be counted in the resulting object. All other strings (either set to false or not included at all in the object) should not be counted. That said, if a particular string is meant to be counted but does not exist in the input array (like "f" in the example above), it also does not have to be included in the final count.

```js
const countOnly = (allItems, itemsToCount) => {
  const results = {}
  // loop over the items
  for (const item of allItems) {
    if (itemsToCount[item]) {
      if (results[item]) {
        results[item] += 1
      } else {
        results[item] = 1
      }
    }
  }
  return results
}

const firstNames = [
  'Karl',
  'Salima',
  'Agouhanna',
  'Fang',
  'Kavith',
  'Jason',
  'Salima',
  'Fang',
  'Joe',
]

const result1 = countOnly(firstNames, { Jason: true, Karima: true, Fang: true, Agouhanna: false })

assertEqual(result1['Jason'], 1)
assertEqual(result1['Karima'], undefined)
assertEqual(result1['Fang'], 2)
assertEqual(result1['Agouhanna'], undefined)

console.log(countOnly(firstNames, { Jason: true, Karima: true, Fang: true, Agouhanna: false }))
// { Fang: 2, Jason: 1 }
```

### countLetters

The function should take in a sentence (as a string) and then return a count of each of the letters in that sentence.

```js
const countLetters = (str) => {
  const result = {}
  // using regex to filter only letters
  for (let char of str.toLowerCase().match(/[a-z]/g)) {
    if (result[char]) {
      result[char] += 1
    } else {
      result[char] = 1
    }
  }
  return result
}

assertEqual(countLetters('Curtis')['c'], 1)
assertEqual(countLetters('aaa')['a'], 3)

console.log(countLetters('Curtis')) // => { c: 1, u: 1, t: 1, i: 1, s: 1 }
```

### letterPosition

Return all the indices (zero-based positions) in the string where each character is found.

```js
const letterPositions = (str) => {
  const result = {}

  for (let i = 0; i < str.length; i++) {
    const char = str[i].toLowerCase()
    if (char.match(/[a-z]/g)) {
      if (result[str[i]]) {
        result[str[i]].push(i)
      } else {
        result[str[i]] = [i]
      }
    }
  }
  return result
}

const res = letterPositions('lighthouse in the house')
console.log(res)
// {
//   l: [0],
//   i: [1, 11],
//   g: [2],
//   h: [3, 5, 15, 18],
//   t: [4, 14],
//   o: [6, 19],
//   u: [7, 20],
//   s: [8, 21],
//   e: [9, 16, 22],
//   n: [12]
// }
```

### findKeyByValue

function `findKeyByValue` which takes in an object and a value. It should scan the object and return the first key which contains the given value. If no key with that given value is found, then it should return undefined.

```js
const findKeyByValue = (object, value) => {
  const objKeysArr = Object.keys(object)
  console.log(objKeysArr)

  for (let key of objKeysArr) {
    console.log(key)
    if (value === object[key]) {
      console.log(key)
      return key
    }
  }
  return undefined
}

const bestTVShowsByGenre = {
  sci_fi: 'The Expanse',
  comedy: 'Brooklyn Nine-Nine',
  drama: 'The Wire',
}
```

### eqObjects

Returns true if both objects have identical keys with identical values. Otherwise you get back a big fat false!

```js
// helper for arrays as values
const eqArrays = (arr1, arr2) => {
  if (arr1.length !== arr2.length) {
    return false
  }
  for (let i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i]) {
      return false
    }
  }
  return true
}

// Returns true if both objects have identical keys with identical values.
// Otherwise you get back a big fat false!

const eqObjects = (object1, object2) => {
  //get arr of keys for each object
  const keysObj1 = Object.keys(object1)
  const keysObj2 = Object.keys(object2)

  // if object keys differ in number
  if (keysObj1.length !== keysObj2.length) {
    return false
  }

  // iterate through one of the keys arr
  for (let key in object1) {
    if (Array.isArray(object1[key]) && Array.isArray(object2[key])) {
      if (!eqArrays(object1[key], object2[key])) {
        return false
      }
    } else if (object1[key] !== object2[key]) {
      return false
    }
  }
  return true
}
```

#### eqObjects recursive

```js
// recursive function to check if two objects are equal
const eqObjects = function (object1, object2) {
  //get arr of keys for each object
  const keysObj1 = Object.keys(object1)
  const keysObj2 = Object.keys(object2)

  // if object keys differ in number
  if (keysObj1.length !== keysObj2.length) {
    return false
  } else {
    // iterate through one of they keysObj array
    for (const key of keysObj1) {
      // check to see if the key is an array
      if (Array.isArray(object1[key]) && Array.isArray(object2[key])) {
        // if the key is an array, call the eqArrays function
        if (!eqArrays(object1[key], object2[key])) {
          return false
        }
      } else if (typeof object1[key] === 'object' && typeof object2[key] === 'object') {
        if (!eqObjects(object1[key], object2[key])) {
          // if so, call the eqObjects function
          return false
        }
      } else {
        if (object1[key] !== object2[key]) {
          return false
        }
      }
    }
    return true
  }
}
```

### assertObjectsEqual

```js
const assertObjectsEqual = (actual, expected) => {
  const inspect = require('util').inspect

  if (eqObjects(actual, expected)) {
    console.log(`✅ Assertion Passed: [${inspect(actual)} === [${inspect(expected)}]`)
  } else {
    console.log(`❌ Assertion Failed: [${inspect(actual)}] !== [${inspect(expected)}]`)
  }
}
```

### map

Making our own version of map. Will take in two arguments (array to map over, and a callback function). It should return a new array with the result of the callback function applied to each element in the array.

```js
const map = function (array, callback) {
  const results = []

  for (let item of array) {
    results.push(callback(item))
  }

  return results
}

/// example of map

const daysOfTheWeek = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']

const result1 = map(daysOfTheWeek, (day) => day[0])

console.log(result1) // => ['M', 'T', 'W', 'T', 'F', 'S', 'S']
```

### takeUntil

Inspired by lodash's [takeWhile function](https://lodash.com/docs/4.17.15#takeWhile).

It will take in two parameters as well:
-The array to work with

- The callback (which Lodash calls "predicate")

The function will return a "slice of the `array` with elements taken from the beginning." It should keep going until the callback/predicate returns a truthy value.

To keep things simple, the callback should only be provided one value: The item in the array.

```js
const takeUntil = (arr, cb) => {
  const result = []

  for (let item of arr) {
    if (!cb(item)) {
      result.push(item)
    } else {
      return result
    }
  }
}

// testing
const data1 = [1, 2, 5, 7, 2, -1, 2, 4, 5]
const results1 = takeUntil(data1, (x) => x < 0)
console.log(results1) // [ 1, 2, 5, 7, 2 ]

const data2 = ["I've", 'been', 'to', 'Hollywood', ',', "I've", 'been', 'to', 'Redwood']
const results2 = takeUntil(data2, (x) => x === ',')
console.log(results2) // [ 'I\'ve', 'been', 'to', 'Hollywood' ]
```

### findKey

Similar to lodash's [findKey function](https://lodash.com/docs/4.17.15#findKey).

Implement the function `findKey` which takes in an object and a callback. It should scan the object and return the first key for which the callback returns a truthy value. If no key is found, then it should return undefined.

```js
const findKey = (object, callback) => {
  for (let item in object) {
    if (callback(object[item])) {
      return item
    }
  }
  return undefined
}

//test case
console.log(
  findKey(
    {
      'Blue Hill': { stars: 1 },
      Akaleri: { stars: 3 },
      noma: { stars: 2 },
      elBulli: { stars: 3 },
      Ora: { stars: 2 },
      Akelarre: { stars: 3 },
    },
    (x) => x.stars === 2
  )
) // => "noma"
```
